#!/usr/bin/env python3
"""
Event Hierarchy Analyzer for Chaukas SDK

Analyzes JSONL event files generated by Chaukas SDK for hierarchy correctness
and visualizes the event tree structure.

Usage:
    python analyze_event_hierarchy.py [file.jsonl]
    python analyze_event_hierarchy.py  # Analyzes all .jsonl files in current directory
"""

import argparse
import json
import sys
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple


class EventHierarchyAnalyzer:
    """Analyzes event hierarchy from Chaukas SDK JSONL output."""

    def __init__(self, filepath: str, verbose: bool = False):
        self.filepath = Path(filepath)
        self.verbose = verbose
        self.events: List[Dict[str, Any]] = []
        self.inconsistencies: List[str] = []
        self.warnings: List[str] = []
        self.span_map: Dict[str, List[Dict]] = {}
        self.parent_child_map: Dict[str, List[str]] = defaultdict(list)
        self.session_id: Optional[str] = None
        self.trace_id: Optional[str] = None
        self.root_spans: Set[str] = set()

    def load_events(self) -> bool:
        """Load events from JSONL file."""
        if not self.filepath.exists():
            print(f"❌ File not found: {self.filepath}")
            return False

        try:
            with open(self.filepath, "r") as f:
                for line_num, line in enumerate(f, 1):
                    if line.strip():
                        try:
                            event = json.loads(line)
                            self.events.append(event)
                        except json.JSONDecodeError as e:
                            self.inconsistencies.append(
                                f"Line {line_num}: Invalid JSON - {e}"
                            )

            if self.verbose:
                print(f"✓ Loaded {len(self.events)} events from {self.filepath.name}")
            return True

        except Exception as e:
            print(f"❌ Error reading file: {e}")
            return False

    def analyze_consistency(self) -> None:
        """Check for ID consistency across events."""
        if not self.events:
            self.inconsistencies.append("No events found in file")
            return

        # Extract unique IDs
        session_ids = set()
        trace_ids = set()

        for event in self.events:
            session_ids.add(event.get("session_id"))
            trace_ids.add(event.get("trace_id"))

        # Check consistency
        if len(session_ids) > 1:
            self.inconsistencies.append(
                f"Multiple session IDs found ({len(session_ids)}): {list(session_ids)[:3]}..."
            )
        else:
            self.session_id = list(session_ids)[0] if session_ids else None

        if len(trace_ids) > 1:
            self.inconsistencies.append(
                f"Multiple trace IDs found ({len(trace_ids)}): {list(trace_ids)[:3]}..."
            )
        else:
            self.trace_id = list(trace_ids)[0] if trace_ids else None

    def build_hierarchy(self) -> None:
        """Build parent-child hierarchy map."""
        # Build span map and identify relationships
        for event in self.events:
            span_id = event.get("span_id")
            parent_span_id = event.get("parent_span_id")

            if span_id:
                if span_id not in self.span_map:
                    self.span_map[span_id] = []
                self.span_map[span_id].append(event)

                if not parent_span_id:
                    self.root_spans.add(span_id)
                else:
                    self.parent_child_map[parent_span_id].append(span_id)

    def detect_inconsistencies(self) -> None:
        """Detect various types of inconsistencies in the event hierarchy."""
        # Check for orphaned parent references
        orphaned_parents = set()
        for parent_id, children in self.parent_child_map.items():
            if parent_id not in self.span_map:
                orphaned_parents.add(parent_id)

        if orphaned_parents:
            for parent in list(orphaned_parents)[:5]:  # Show max 5
                child_events = []
                for event in self.events:
                    if event.get("parent_span_id") == parent:
                        child_events.append(
                            event.get("type", "UNKNOWN").replace("EVENT_TYPE_", "")
                        )
                self.inconsistencies.append(
                    f"Orphaned parent span: {parent[:12]}... (referenced by: {', '.join(child_events[:3])})"
                )

        # Check for unpaired START/END events
        start_events = {}
        end_events = {}

        for event in self.events:
            event_type = event.get("type", "")
            span_id = event.get("span_id")

            if "_START" in event_type:
                base_type = event_type.replace("_START", "")
                if base_type not in start_events:
                    start_events[base_type] = []
                start_events[base_type].append(span_id)
            elif "_END" in event_type:
                base_type = event_type.replace("_END", "")
                if base_type not in end_events:
                    end_events[base_type] = []
                end_events[base_type].append(span_id)

        # Compare START and END events
        for event_type in set(list(start_events.keys()) + list(end_events.keys())):
            starts = start_events.get(event_type, [])
            ends = end_events.get(event_type, [])

            if len(starts) != len(ends):
                self.warnings.append(
                    f"Unpaired {event_type}: {len(starts)} START vs {len(ends)} END events"
                )

        # Check for circular dependencies
        def has_cycle(node: str, visited: Set[str], rec_stack: Set[str]) -> bool:
            visited.add(node)
            rec_stack.add(node)

            for child in self.parent_child_map.get(node, []):
                if child not in visited:
                    if has_cycle(child, visited, rec_stack):
                        return True
                elif child in rec_stack:
                    return True

            rec_stack.remove(node)
            return False

        visited = set()
        for span_id in self.span_map:
            if span_id not in visited:
                if has_cycle(span_id, visited, set()):
                    self.inconsistencies.append(
                        f"Circular dependency detected involving span: {span_id[:12]}..."
                    )
                    break

    def generate_ascii_tree(self) -> str:
        """Generate ASCII visualization of the event hierarchy."""
        output = []

        def format_event(event: Dict) -> str:
            """Format a single event for display."""
            event_type = event.get("type", "UNKNOWN").replace("EVENT_TYPE_", "")
            agent_name = event.get("agent_name", "")
            agent_id = event.get("agent_id", "")

            # Add contextual information based on event type
            extra_info = ""
            if "MODEL_INVOCATION" in event_type:
                llm_data = event.get("llm_invocation", {})
                model = llm_data.get("model", "unknown")
                extra_info = f" [{model}]"
            elif "TOOL_CALL" in event_type:
                tool_data = event.get("tool_call", {})
                tool_name = tool_data.get("name", "unknown")
                extra_info = f" [{tool_name}]"
            elif "MCP_CALL" in event_type:
                mcp_data = event.get("mcp_call", {})
                operation = mcp_data.get("operation", "unknown")
                extra_info = f" [{operation}]"
            elif agent_name:
                extra_info = f" [{agent_name}]"
            elif "INPUT" in event_type or "OUTPUT" in event_type:
                message = event.get("message", {})
                role = message.get("role", "")
                text = message.get("text", "")[:50]
                extra_info = f' [{role}] "{text}..."'

            return f"{event_type}{extra_info}"

        def print_tree(
            span_id: str, indent: int = 0, is_last: bool = True, parent_prefix: str = ""
        ) -> None:
            """Recursively print the tree structure."""
            if span_id in self.span_map:
                events = self.span_map[span_id]

                for i, event in enumerate(events):
                    # Determine the connector
                    if indent == 0:
                        connector = ""
                        new_prefix = ""
                    else:
                        if i == 0:
                            connector = "└── " if is_last else "├── "
                        else:
                            connector = "    " if is_last else "│   "
                            connector += "└─ "
                        new_prefix = parent_prefix + ("    " if is_last else "│   ")

                    # Format and add the event
                    formatted = format_event(event)
                    span_info = f" [{span_id[:8]}...]" if self.verbose else ""
                    output.append(f"{parent_prefix}{connector}{formatted}{span_info}")

            # Process children
            children = self.parent_child_map.get(span_id, [])
            # Remove duplicates while preserving order
            seen = set()
            unique_children = []
            for child in children:
                if child not in seen:
                    seen.add(child)
                    unique_children.append(child)

            for i, child_span in enumerate(unique_children):
                is_last_child = i == len(unique_children) - 1
                print_tree(
                    child_span,
                    indent + 1,
                    is_last_child,
                    parent_prefix + ("    " if is_last else "│   "),
                )

        # Find root spans (SESSION events or spans without parents)
        session_spans = []
        for span_id, events in self.span_map.items():
            for event in events:
                if "SESSION_START" in event.get("type", ""):
                    session_spans.append(span_id)
                    break

        if session_spans:
            output.append(
                f"SESSION [{self.session_id[:12] if self.session_id else 'unknown'}...]"
            )
            for span in session_spans:
                print_tree(span, 0)
        else:
            # No session span found, print from root spans
            for span_id in self.root_spans:
                print_tree(span_id, 0)

        return "\n".join(output)

    def write_debug_report(self) -> None:
        """Write detailed debug report to .dbg file."""
        debug_file = self.filepath.with_suffix(".dbg")

        with open(debug_file, "w") as f:
            f.write("CHAUKAS EVENT HIERARCHY DEBUG REPORT\n")
            f.write("=" * 80 + "\n")
            f.write(f"Generated: {datetime.now().isoformat()}\n")
            f.write(f"Input File: {self.filepath.name}\n")
            f.write("\n")

            # Summary
            f.write("=== SUMMARY ===\n")
            f.write(f"Total Events: {len(self.events)}\n")
            f.write(f"Session ID: {self.session_id or 'Multiple/None'}\n")
            f.write(f"Trace ID: {self.trace_id or 'Multiple/None'}\n")
            f.write(f"Unique Spans: {len(self.span_map)}\n")
            f.write(f"Root Spans: {len(self.root_spans)}\n")

            if self.events:
                # Calculate execution time
                timestamps = []
                for event in self.events:
                    ts = event.get("timestamp")
                    if ts:
                        try:
                            timestamps.append(
                                datetime.fromisoformat(ts.replace("Z", "+00:00"))
                            )
                        except:
                            pass

                if len(timestamps) >= 2:
                    duration = (max(timestamps) - min(timestamps)).total_seconds()
                    f.write(f"Execution Time: {duration:.2f} seconds\n")

            f.write("\n")

            # Consistency Checks
            f.write("=== CONSISTENCY CHECKS ===\n")
            checks = [
                (
                    "Session ID Consistency",
                    len(set(e.get("session_id") for e in self.events)) <= 1,
                ),
                (
                    "Trace ID Consistency",
                    len(set(e.get("trace_id") for e in self.events)) <= 1,
                ),
                (
                    "No Orphaned Parents",
                    len([p for p in self.parent_child_map if p not in self.span_map])
                    == 0,
                ),
                ("No Circular Dependencies", True),  # Simplified for now
            ]

            for check_name, passed in checks:
                status = "✓ PASS" if passed else "✗ FAIL"
                f.write(f"[{status}] {check_name}\n")

            f.write("\n")

            # Inconsistencies
            if self.inconsistencies:
                f.write("=== INCONSISTENCIES FOUND ===\n")
                for i, issue in enumerate(self.inconsistencies, 1):
                    f.write(f"{i}. {issue}\n")
                f.write("\n")

            # Warnings
            if self.warnings:
                f.write("=== WARNINGS ===\n")
                for i, warning in enumerate(self.warnings, 1):
                    f.write(f"{i}. {warning}\n")
                f.write("\n")

            # Hierarchy Map
            f.write("=== HIERARCHY MAP ===\n")
            f.write(self.generate_ascii_tree())
            f.write("\n\n")

            # Event Timeline
            f.write("=== EVENT TIMELINE ===\n")
            sorted_events = sorted(self.events, key=lambda e: e.get("timestamp", ""))
            for event in sorted_events[:50]:  # Show first 50 events
                timestamp = event.get("timestamp", "unknown")
                event_type = event.get("type", "UNKNOWN").replace("EVENT_TYPE_", "")
                span_id = event.get("span_id", "unknown")[:12]
                parent = (
                    event.get("parent_span_id", "none")[:12]
                    if event.get("parent_span_id")
                    else "none"
                )
                f.write(
                    f"{timestamp} | {event_type:30} | span:{span_id} | parent:{parent}\n"
                )

            if len(sorted_events) > 50:
                f.write(f"... and {len(sorted_events) - 50} more events\n")

            f.write("\n")

            # Recommendations
            f.write("=== RECOMMENDATIONS ===\n")
            if not self.inconsistencies and not self.warnings:
                f.write("✅ Event hierarchy is properly structured.\n")
            else:
                if self.inconsistencies:
                    f.write("⚠️  Fix the inconsistencies listed above:\n")
                    if any("Orphaned parent" in i for i in self.inconsistencies):
                        f.write("   - Ensure all parent spans are emitted as events\n")
                    if any("Multiple session" in i for i in self.inconsistencies):
                        f.write("   - Ensure session context is properly maintained\n")
                    if any("Multiple trace" in i for i in self.inconsistencies):
                        f.write("   - Ensure trace context is properly maintained\n")

                if self.warnings:
                    f.write("⚠️  Review the warnings:\n")
                    if any("Unpaired" in w for w in self.warnings):
                        f.write(
                            "   - Ensure all START events have corresponding END events\n"
                        )

        print(f"Debug report written to: {debug_file}")

    def run(self) -> bool:
        """Main analysis workflow."""
        print(f"\nEvent Hierarchy Analysis: {self.filepath.name}")
        print("=" * 80)

        # Load events
        if not self.load_events():
            return False

        if not self.events:
            print("❌ No events found in file")
            return False

        # Analyze
        self.analyze_consistency()
        self.build_hierarchy()
        self.detect_inconsistencies()

        # Display summary
        print(f"\nSession: {self.session_id[:40] if self.session_id else 'Unknown'}...")
        print(f"Trace:   {self.trace_id[:40] if self.trace_id else 'Unknown'}...")
        print(f"Events:  {len(self.events)} total")

        # Display hierarchy
        print("\nHIERARCHY TREE:")
        print("─" * 80)
        tree = self.generate_ascii_tree()
        print(tree)
        print()

        # Display validation results
        if not self.inconsistencies and not self.warnings:
            print("✅ VALIDATION PASSED")
            print("  • All events share same session_id")
            print("  • All events share same trace_id")
            print("  • No orphaned spans detected")
            print("  • All START/END events properly paired")
        else:
            print("⚠️  VALIDATION ISSUES FOUND")

            if self.inconsistencies:
                print("\nInconsistencies:")
                for issue in self.inconsistencies[:5]:
                    print(f"  ❌ {issue}")
                if len(self.inconsistencies) > 5:
                    print(f"  ... and {len(self.inconsistencies) - 5} more")

            if self.warnings:
                print("\nWarnings:")
                for warning in self.warnings[:5]:
                    print(f"  ⚠️  {warning}")
                if len(self.warnings) > 5:
                    print(f"  ... and {len(self.warnings) - 5} more")

        # Write debug report
        print()
        self.write_debug_report()

        return not bool(self.inconsistencies)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Analyze Chaukas SDK event hierarchy from JSONL files"
    )
    parser.add_argument(
        "file",
        nargs="?",
        help="JSONL file to analyze (analyzes all .jsonl files if not specified)",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose output"
    )

    args = parser.parse_args()

    # Determine which files to analyze
    if args.file:
        files = [Path(args.file)]
    else:
        files = list(Path.cwd().glob("*.jsonl"))
        if not files:
            print("No JSONL files found in current directory")
            sys.exit(1)

    # Analyze each file
    all_passed = True
    for filepath in files:
        analyzer = EventHierarchyAnalyzer(filepath, verbose=args.verbose)
        passed = analyzer.run()
        all_passed = all_passed and passed

    # Exit with appropriate code
    sys.exit(0 if all_passed else 1)


if __name__ == "__main__":
    main()
